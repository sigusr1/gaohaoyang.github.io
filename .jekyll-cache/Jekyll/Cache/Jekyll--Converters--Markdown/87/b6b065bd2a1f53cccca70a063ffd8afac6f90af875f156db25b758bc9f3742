I" *<ul id="markdown-toc">
  <li><a href="#一预备知识" id="markdown-toc-一预备知识">一、预备知识</a></li>
  <li><a href="#二实验环境" id="markdown-toc-二实验环境">二、实验环境</a></li>
  <li><a href="#三剖析一个简单的python脚本" id="markdown-toc-三剖析一个简单的python脚本">三、剖析一个简单的Python脚本</a>    <ul>
      <li><a href="#python中的字节对象bytes-object" id="markdown-toc-python中的字节对象bytes-object">Python中的字节对象(bytes object)</a>        <ul>
          <li><a href="#字节和字符串bytes-vs-str" id="markdown-toc-字节和字符串bytes-vs-str">字节和字符串(bytes vs str)</a></li>
          <li><a href="#一切都是对象" id="markdown-toc-一切都是对象">一切都是对象</a></li>
        </ul>
      </li>
      <li><a href="#对python脚本执行read_write_heappy脚本" id="markdown-toc-对python脚本执行read_write_heappy脚本">对python脚本执行read_write_heap.py脚本</a></li>
    </ul>
  </li>
  <li><a href="#四从python实现中寻找目标字符串" id="markdown-toc-四从python实现中寻找目标字符串">四、从Python实现中寻找目标字符串</a>    <ul>
      <li><a href="#id" id="markdown-toc-id">id</a></li>
      <li><a href="#bytesobjecth" id="markdown-toc-bytesobjecth">bytesobject.h</a></li>
    </ul>
  </li>
  <li><a href="#五从内存中寻找目标字符串" id="markdown-toc-五从内存中寻找目标字符串">五、从内存中寻找目标字符串</a>    <ul>
      <li><a href="#c函数原型" id="markdown-toc-c函数原型">C函数原型</a></li>
      <li><a href="#objecth" id="markdown-toc-objecth">object.h</a></li>
      <li><a href="#c函数实现" id="markdown-toc-c函数实现">C函数实现</a></li>
      <li><a href="#python调用c函数" id="markdown-toc-python调用c函数">Python调用C函数</a>        <ul>
          <li><a href="#创建动态库" id="markdown-toc-创建动态库">创建动态库</a></li>
          <li><a href="#调用动态库" id="markdown-toc-调用动态库">调用动态库</a></li>
          <li><a href="#打印python对象的脚本" id="markdown-toc-打印python对象的脚本">打印Python对象的脚本</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#六替换python进程的字符串" id="markdown-toc-六替换python进程的字符串">六、替换Python进程的字符串</a></li>
  <li><a href="#七下节预告" id="markdown-toc-七下节预告">七、下节预告</a></li>
  <li><a href="#八继续阅读" id="markdown-toc-八继续阅读">八、继续阅读</a></li>
  <li><a href="#九原文链接" id="markdown-toc-九原文链接">九、原文链接</a></li>
</ul>
<p>这是虚拟内存系列文章的第二篇。<br />
这次我们要做的事情和<a href="http://blog.coderhuo.tech/2017/10/12/Virtual_Memory_C_strings_proc/">《虚拟内存探究 – 第一篇:C strings &amp; /proc》</a>类似，不同的是我们将访问Python 3 脚本的虚拟内存。这会比较费劲， 所以我们需要了解Pyhton3 内部的一些机制。</p>

<h2 id="一预备知识">一、预备知识</h2>
<p>本文基于上一篇文章<a href="http://blog.coderhuo.tech/2017/10/12/Virtual_Memory_C_strings_proc/">《虚拟内存探究 – 第一篇:C strings &amp; /proc》</a>中所讲的知识， 所以，在继续阅读本文前，请确保阅读并理解上一篇文章。</p>

<p>为了方便理解本文，你需要具备以下知识：</p>

<ul>
  <li>C语言基础</li>
  <li>些许Python知识</li>
  <li>了解Linux的文件系统和shell命令</li>
  <li><code class="highlighter-rouge">/proc</code>文件系统的基本知识（可参阅<a href="http://blog.coderhuo.tech/2017/10/12/Virtual_Memory_C_strings_proc/">《虚拟内存探究 – 第一篇:C strings &amp; /proc》</a>中的相关介绍）</li>
</ul>

<h2 id="二实验环境">二、实验环境</h2>
<p>所有的脚本和程序都在下面的环境中测试过：</p>

<ul>
  <li>Ubuntu 14.04 LTS
    <ul>
      <li>Linux ubuntu 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:07:32 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</li>
    </ul>
  </li>
  <li>gcc
    <ul>
      <li>gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4</li>
    </ul>
  </li>
  <li>Python 3
    <ul>
      <li>Python 3.4.3 (default, Nov 17 2016, 01:08:31)</li>
      <li>[GCC 4.8.4] on linux</li>
    </ul>
  </li>
</ul>

<h2 id="三剖析一个简单的python脚本">三、剖析一个简单的Python脚本</h2>

<p>下面是我们将要使用的Python脚本（<code class="highlighter-rouge">main.py</code>）。我们将尝试修改运行该脚本的进程虚拟内存中的“字符串” <code class="highlighter-rouge">Holberton</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span><span class="s">'''
Prints a b"string" (bytes object), reads a char from stdin
and prints the same (or not :)) string again
'''</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">s</span> <span class="o">=</span> <span class="s">b"Holberton"</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="python中的字节对象bytes-object">Python中的字节对象(bytes object)</h3>

<h4 id="字节和字符串bytes-vs-str">字节和字符串(bytes vs str)</h4>
<p><em>译者注:bytes在这里翻译成字节， 并非指单个字符。</em></p>

<p>如上面代码所示，我们使用一个字节对象（字符串<code class="highlighter-rouge">Holberton</code>前面的<code class="highlighter-rouge">b</code>说明这是个字节对象）来存储字符串<code class="highlighter-rouge">Holberton</code>。字节对象会把字符串中的字符以字节的形式（相对于每个字符占多个字节的字符串编码方式而言，也就是宽字符编码，具体可参阅<code class="highlighter-rouge">unicodeobject.h</code>）存下来。这样可以保证字符串在虚拟内存中是连续的ASCII码。</p>

<p>从技术上来讲， 上面代码中的<code class="highlighter-rouge">s</code>并不是一个Python字符串。如下所示， 它是一个字节对象(不过没关系, 这不影响我们的后续讨论)：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ python3
Python 3.4.3 (default, Nov 17 2016, 01:08:31) 
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; s = "Betty"
&gt;&gt;&gt; type(s)
&lt;class 'str'&gt;
&gt;&gt;&gt; s = b"Betty"
&gt;&gt;&gt; type(s)
&lt;class 'bytes'&gt;
&gt;&gt;&gt; quit()
</code></pre></div></div>

<h4 id="一切都是对象">一切都是对象</h4>

<p>Pyhton中的整数、字符串、字节、函数等等， 都是对象。所以， 语句<code class="highlighter-rouge">s = b"Holberton"</code>将创建一个字节对象，并将字符串存在内存中某处。字符串<code class="highlighter-rouge">Holberton</code>很可能在堆上，因为Python必须为字节对象<code class="highlighter-rouge">s</code>以及<code class="highlighter-rouge">s</code>指向的字符串分配内存（字符串可能直接存在对象<code class="highlighter-rouge">s</code>中，也可能<code class="highlighter-rouge">s</code>只维护了一个指向字符串的索引，目前我们并不确定具体的实现）。</p>

<h3 id="对python脚本执行read_write_heappy脚本">对python脚本执行read_write_heap.py脚本</h3>
<p><em>提示：<code class="highlighter-rouge">read_write_heap.py</code>是<a href="http://blog.coderhuo.tech/2017/10/12/Virtual_Memory_C_strings_proc/">《虚拟内存探究 – 第一篇:C strings &amp; /proc》</a>中的脚本，用来查找并替换内存中的字符串。</em></p>

<p>我们首先执行前面的脚本<code class="highlighter-rouge">main.py</code>：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ./main.py 
b'Holberton'
</code></pre></div></div>

<p>这时<code class="highlighter-rouge">main.py</code>阻塞在语句<code class="highlighter-rouge">sys.stdin.read(1)</code>上，一直在等待用户输入。</p>

<p>接下来我们用管理员权限执行脚本<code class="highlighter-rouge">read_write_heap.py</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ps aux | grep main.py | grep -v grep
julien     3929  0.0  0.7  31412  7848 pts/0    S+   15:10   0:00 python3 ./main.py
julien@holberton:~/holberton/w/hackthevm1$ sudo ./read_write_heap.py 3929 Holberton "~ Betty ~"
[*] maps: /proc/3929/maps
[*] mem: /proc/3929/mem
[*] Found [heap]:
    pathname = [heap]
    addresses = 022dc000-023c6000
    permisions = rw-p
    offset = 00000000
    inode = 0
    Addr start [22dc000] | end [23c6000]
[*] Found 'Holberton' at 8e192
[*] Writing '~ Betty ~' at 236a192
julien@holberton:~/holberton/w/hackthevm1$ 
</code></pre></div></div>

<p>不出所料，我们在堆上找到了字符串<code class="highlighter-rouge">Holberton</code>并且将之替换成’~ Betty ~’。<br />
现在我们按下回车键让脚本<code class="highlighter-rouge">main.py</code>继续执行，它应该会输出<code class="highlighter-rouge">b'~ Betty ~'</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b'Holberton'
julien@holberton:~/holberton/w/hackthevm1$
</code></pre></div></div>

<p><strong>什么？？？</strong><br />
<img src="http://data.coderhuo.tech/blog/virtual_memory/giphy-4.gif" alt="**这不可能！！！**" /></p>

<p>我们找到字符串<code class="highlighter-rouge">Holberton</code>并且替换了它，但是这不是我们要找的字符串？继续深入探究之前，我们需要再确认一件事情。我们的脚本<code class="highlighter-rouge">read_write_heap.py</code>在目标字符串首次出现之后就退出了，如果堆中有多个字符串<code class="highlighter-rouge">Holberton</code>呢？为了避免遗漏，我们将脚本<code class="highlighter-rouge">read_write_heap.py</code>执行多次。</p>

<p>还是先启动脚本<code class="highlighter-rouge">main.py</code>：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ./main.py 
b'Holberton'
</code></pre></div></div>
<p>然后多次执行脚本<code class="highlighter-rouge">read_write_heap.py</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ps aux | grep main.py | grep -v grep
julien     4051  0.1  0.7  31412  7832 pts/0    S+   15:53   0:00 python3 ./main.py
julien@holberton:~/holberton/w/hackthevm1$ sudo ./read_write_heap.py 4051 Holberton "~ Betty ~"
[*] maps: /proc/4051/maps
[*] mem: /proc/4051/mem
[*] Found [heap]:
    pathname = [heap]
    addresses = 00bf4000-00cde000
    permisions = rw-p
    offset = 00000000
    inode = 0
    Addr start [bf4000] | end [cde000]
[*] Found 'Holberton' at 8e162
[*] Writing '~ Betty ~' at c82162
julien@holberton:~/holberton/w/hackthevm1$ sudo ./read_write_heap.py 4051 Holberton "~ Betty ~"
[*] maps: /proc/4051/maps
[*] mem: /proc/4051/mem
[*] Found [heap]:
    pathname = [heap]
    addresses = 00bf4000-00cde000
    permisions = rw-p
    offset = 00000000
    inode = 0
    Addr start [bf4000] | end [cde000]
Can't find 'Holberton'
julien@holberton:~/holberton/w/hackthevm1$ 
</code></pre></div></div>

<p>字符串’Holberton’在堆上只出现了一次。那么脚本<code class="highlighter-rouge">main.py</code>所使用的字符串’Holberton’到底在哪里呢？Python的字节对象又是在内存的哪部分呢？有没有可能在栈上？我们可以把脚本<code class="highlighter-rouge">read_write_heap.py</code>中的<code class="highlighter-rouge">[heap]</code>改成<code class="highlighter-rouge">[stack]</code>试试看。</p>

<p><em>提示:文件<code class="highlighter-rouge">/proc/[pid]/maps</code>中标记为<code class="highlighter-rouge">[stack]</code>的部分就是栈， 具体可参阅上一篇文件<a href="http://blog.coderhuo.tech/2017/10/12/Virtual_Memory_C_strings_proc/">《虚拟内存探究 – 第一篇:C strings &amp; /proc》</a>。</em></p>

<p>改写栈的脚本<code class="highlighter-rouge">read_write_stack.py</code>如下， 它所做的和之前的脚本<code class="highlighter-rouge">read_write_heap.py</code>一样，唯一的不同是它访问进程的栈：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span><span class="s">'''
Locates and replaces the first occurrence of a string in the stack
of a process

Usage: ./read_write_stack.py PID search_string replace_by_string
Where:
- PID is the pid of the target process
- search_string is the ASCII string you are looking to overwrite
- replace_by_string is the ASCII string you want to replace
search_string with
'''</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">print_usage_and_exit</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Usage: {} pid search write'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># check usage
</span><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">print_usage_and_exit</span><span class="p">()</span>

<span class="c1"># get the pid from args
</span><span class="n">pid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">if</span> <span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">print_usage_and_exit</span><span class="p">()</span>
<span class="n">search_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="k">if</span> <span class="n">search_string</span>  <span class="o">==</span> <span class="s">""</span><span class="p">:</span>
    <span class="n">print_usage_and_exit</span><span class="p">()</span>
<span class="n">write_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="k">if</span> <span class="n">search_string</span>  <span class="o">==</span> <span class="s">""</span><span class="p">:</span>
    <span class="n">print_usage_and_exit</span><span class="p">()</span>

<span class="c1"># open the maps and mem files of the process
</span><span class="n">maps_filename</span> <span class="o">=</span> <span class="s">"/proc/{}/maps"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"[*] maps: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">maps_filename</span><span class="p">))</span>
<span class="n">mem_filename</span> <span class="o">=</span> <span class="s">"/proc/{}/mem"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"[*] mem: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mem_filename</span><span class="p">))</span>

<span class="c1"># try opening the maps file
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">maps_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'/proc/{}/maps'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pid</span><span class="p">),</span> <span class="s">'r'</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"[ERROR] Can not open file {}:"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">maps_filename</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"        I/O error({}): {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">strerror</span><span class="p">))</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">maps_file</span><span class="p">:</span>
    <span class="n">sline</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="c1"># check if we found the stack
</span>    <span class="k">if</span> <span class="n">sline</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"[stack]"</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"[*] Found [stack]:"</span><span class="p">)</span>

    <span class="c1"># parse line
</span>    <span class="n">addr</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">inode</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">pathname</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">pathname = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">addresses = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">permisions = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">perm</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">offset = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">inode = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>

    <span class="c1"># check if there is read and write permission
</span>    <span class="k">if</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'r'</span> <span class="ow">or</span> <span class="n">perm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'w'</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"[*] {} does not have read/write permission"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span>
        <span class="n">maps_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># get start and end of the stack in the virtual memory
</span>    <span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">"-"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># never trust anyone, not even your OS :)
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"[*] Wrong addr format"</span><span class="p">)</span>
        <span class="n">maps_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">addr_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">addr_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">Addr start [{:x}] | end [{:x}]"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">addr_start</span><span class="p">,</span> <span class="n">addr_end</span><span class="p">))</span>

    <span class="c1"># open and read mem
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="n">mem_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">mem_filename</span><span class="p">,</span> <span class="s">'rb+'</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"[ERROR] Can not open file {}:"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mem_filename</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"        I/O error({}): {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">strerror</span><span class="p">))</span>
        <span class="n">maps_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># read stack
</span>    <span class="n">mem_file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">addr_start</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">mem_file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">addr_end</span> <span class="o">-</span> <span class="n">addr_start</span><span class="p">)</span>

    <span class="c1"># find string
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">search_string</span><span class="p">,</span> <span class="s">"ASCII"</span><span class="p">))</span>
    <span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Can't find '{}'"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">search_string</span><span class="p">))</span>
        <span class="n">maps_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">mem_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"[*] Found '{}' at {:x}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">search_string</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="c1"># write the new stringprint("[*] Writing '{}' at {:x}".format(write_string, addr_start + i))
</span>    <span class="n">mem_file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">addr_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">mem_file</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">write_string</span><span class="p">,</span> <span class="s">"ASCII"</span><span class="p">))</span>

    <span class="c1"># close filesmaps_file.close()
</span>    <span class="n">mem_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># there is only one stack in our example
</span>    <span class="k">break</span>
</code></pre></div></div>

<p>我们依次执行脚本<code class="highlighter-rouge">main.py</code>和<code class="highlighter-rouge">read_write_stack.py</code>尝试在栈上寻找字符串:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ./main.py
b'Holberton'
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ps aux | grep main.py | grep -v grep
julien     4124  0.2  0.7  31412  7848 pts/0    S+   16:10   0:00 python3 ./main.py
julien@holberton:~/holberton/w/hackthevm1$ sudo ./read_write_stack.py 4124 Holberton "~ Betty ~"
[sudo] password for julien: 
[*] maps: /proc/4124/maps
[*] mem: /proc/4124/mem
[*] Found [stack]:
    pathname = [stack]
    addresses = 7fff2997e000-7fff2999f000
    permisions = rw-p
    offset = 00000000
    inode = 0
    Addr start [7fff2997e000] | end [7fff2999f000]
Can't find 'Holberton'
julien@holberton:~/holberton/w/hackthevm1$ 
</code></pre></div></div>
<p>由此可见， 我们的字符串既不在栈上也不在堆上。它究竟在哪里呢？<br />
我们只有从Python3的内部实现中去寻找答案。</p>

<h2 id="四从python实现中寻找目标字符串">四、从Python实现中寻找目标字符串</h2>

<p><em>提示：Python3有很多实现版本，本文使用的是最原始的、最常用的CPython（用C语言实现的）。后续有关Python3的讨论都是基于CPython。</em></p>

<h3 id="id">id</h3>

<p>有个简单的方法可以知道python的对象（注意：是对象不是字符串）位于虚拟内存的哪部分。CPython的内置函数<code class="highlighter-rouge">id()</code>实现比较特别，它返回对象的内存地址。</p>

<p>下面的脚本<code class="highlighter-rouge">main_id.py</code>在<code class="highlighter-rouge">main.py</code>的基础上添加了打印对象id的语句，也就可以获得对象内存地址:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span><span class="s">'''
Prints:
- the address of the bytes object
- a b"string" (bytes object)
reads a char from stdin
and prints the same (or not :)) string again
'''</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">s</span> <span class="o">=</span> <span class="s">b"Holberton"</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ./main_id.py
0x7f343f010210
b'Holberton'
</code></pre></div></div>

<p>字节对象s的内存地址是<code class="highlighter-rouge">0x7f343f010210</code>。通过<code class="highlighter-rouge">/proc</code>可以查看对象到底位于哪里。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:/usr/include/python3.4$ ps aux | grep main_id.py | grep -v grep
julien     4344  0.0  0.7  31412  7856 pts/0    S+   16:53   0:00 python3 ./main_id.py
julien@holberton:/usr/include/python3.4$ cat /proc/4344/maps
00400000-006fa000 r-xp 00000000 08:01 655561                             /usr/bin/python3.4
008f9000-008fa000 r--p 002f9000 08:01 655561                             /usr/bin/python3.4
008fa000-00986000 rw-p 002fa000 08:01 655561                             /usr/bin/python3.4
00986000-009a2000 rw-p 00000000 00:00 0 
021ba000-022a4000 rw-p 00000000 00:00 0                                  [heap]
7f343d797000-7f343de79000 r--p 00000000 08:01 663747                     /usr/lib/locale/locale-archive
7f343de79000-7f343df7e000 r-xp 00000000 08:01 136303                     /lib/x86_64-linux-gnu/libm-2.19.so
7f343df7e000-7f343e17d000 ---p 00105000 08:01 136303                     /lib/x86_64-linux-gnu/libm-2.19.so
7f343e17d000-7f343e17e000 r--p 00104000 08:01 136303                     /lib/x86_64-linux-gnu/libm-2.19.so
7f343e17e000-7f343e17f000 rw-p 00105000 08:01 136303                     /lib/x86_64-linux-gnu/libm-2.19.so
7f343e17f000-7f343e197000 r-xp 00000000 08:01 136416                     /lib/x86_64-linux-gnu/libz.so.1.2.8
7f343e197000-7f343e396000 ---p 00018000 08:01 136416                     /lib/x86_64-linux-gnu/libz.so.1.2.8
7f343e396000-7f343e397000 r--p 00017000 08:01 136416                     /lib/x86_64-linux-gnu/libz.so.1.2.8
7f343e397000-7f343e398000 rw-p 00018000 08:01 136416                     /lib/x86_64-linux-gnu/libz.so.1.2.8
7f343e398000-7f343e3bf000 r-xp 00000000 08:01 136275                     /lib/x86_64-linux-gnu/libexpat.so.1.6.0
7f343e3bf000-7f343e5bf000 ---p 00027000 08:01 136275                     /lib/x86_64-linux-gnu/libexpat.so.1.6.0
7f343e5bf000-7f343e5c1000 r--p 00027000 08:01 136275                     /lib/x86_64-linux-gnu/libexpat.so.1.6.0
7f343e5c1000-7f343e5c2000 rw-p 00029000 08:01 136275                     /lib/x86_64-linux-gnu/libexpat.so.1.6.0
7f343e5c2000-7f343e5c4000 r-xp 00000000 08:01 136408                     /lib/x86_64-linux-gnu/libutil-2.19.so
7f343e5c4000-7f343e7c3000 ---p 00002000 08:01 136408                     /lib/x86_64-linux-gnu/libutil-2.19.so
7f343e7c3000-7f343e7c4000 r--p 00001000 08:01 136408                     /lib/x86_64-linux-gnu/libutil-2.19.so
7f343e7c4000-7f343e7c5000 rw-p 00002000 08:01 136408                     /lib/x86_64-linux-gnu/libutil-2.19.so
7f343e7c5000-7f343e7c8000 r-xp 00000000 08:01 136270                     /lib/x86_64-linux-gnu/libdl-2.19.so
7f343e7c8000-7f343e9c7000 ---p 00003000 08:01 136270                     /lib/x86_64-linux-gnu/libdl-2.19.so
7f343e9c7000-7f343e9c8000 r--p 00002000 08:01 136270                     /lib/x86_64-linux-gnu/libdl-2.19.so
7f343e9c8000-7f343e9c9000 rw-p 00003000 08:01 136270                     /lib/x86_64-linux-gnu/libdl-2.19.so
7f343e9c9000-7f343eb83000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so
7f343eb83000-7f343ed83000 ---p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so
7f343ed83000-7f343ed87000 r--p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so
7f343ed87000-7f343ed89000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so
7f343ed89000-7f343ed8e000 rw-p 00000000 00:00 0 
7f343ed8e000-7f343eda7000 r-xp 00000000 08:01 136373                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f343eda7000-7f343efa6000 ---p 00019000 08:01 136373                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f343efa6000-7f343efa7000 r--p 00018000 08:01 136373                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f343efa7000-7f343efa8000 rw-p 00019000 08:01 136373                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f343efa8000-7f343efac000 rw-p 00000000 00:00 0 
7f343efac000-7f343efcf000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so
7f343f000000-7f343f1b6000 rw-p 00000000 00:00 0 
7f343f1c5000-7f343f1cc000 r--s 00000000 08:01 918462                     /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
7f343f1cc000-7f343f1ce000 rw-p 00000000 00:00 0 
7f343f1ce000-7f343f1cf000 r--p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so
7f343f1cf000-7f343f1d0000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so
7f343f1d0000-7f343f1d1000 rw-p 00000000 00:00 0 
7ffccf1fd000-7ffccf21e000 rw-p 00000000 00:00 0                          [stack]
7ffccf23c000-7ffccf23e000 r--p 00000000 00:00 0                          [vvar]
7ffccf23e000-7ffccf240000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
julien@holberton:/usr/include/python3.4$ 
</code></pre></div></div>

<p>字节对象s位于以下内存区域:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7f343f000000-7f343f1b6000 rw-p 00000000 00:00 0
</code></pre></div></div>
<p>这既不是堆也不是栈，这也说明了为什么我们替换字符串一直没有成功。但这并不意味着字符串本身也存放在这一内存区域。比如，字节对象<code class="highlighter-rouge">s</code>可以维护一个指向字符串的指针，而不是把字符串复制一份。当然，我们可以粗暴的搜索这一内存区域来查看字符串是不是在这里。先别急， 我们先多了解下Pyhton中的字节对象。</p>
<h3 id="bytesobjecth">bytesobject.h</h3>

<p>我们使用的是C语言实现的Pyhton(CPyhton），所以让我们先看下字节对象的头文件。</p>

<p><em>提示:如果你没有Python3的头文件，在<code class="highlighter-rouge">Ubuntu</code>上可以通过命令<code class="highlighter-rouge">sudo apt-get install python3-dev</code>下载。如果你的环境和我一样，Pyhton3的头文件应该位于目录<code class="highlighter-rouge">/usr/include/python3.4/</code>。</em></p>

<p>由<code class="highlighter-rouge">bytesobject.h</code>可见：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct {
    PyObject_VAR_HEAD
    Py_hash_t ob_shash;
    char ob_sval[1];

    /* Invariants:
     *     ob_sval contains space for 'ob_size+1' elements.
     *     ob_sval[ob_size] == 0.
     *     ob_shash is the hash of the string or -1 if not computed yet.
     */
} PyBytesObject;
</code></pre></div></div>

<p>这意味着什么？</p>

<ul>
  <li>Pyhton3中的字节对象对应的内部类型是<code class="highlighter-rouge">PyBytesObject</code></li>
  <li><code class="highlighter-rouge">ob_sval</code>中存放着整个字符串</li>
  <li>字符串是以<code class="highlighter-rouge">0x0</code>（<code class="highlighter-rouge">NULL</code>）结尾的</li>
  <li><code class="highlighter-rouge">ob_size </code>中存放着字符串的长度（<code class="highlighter-rouge">ob_size </code>在<code class="highlighter-rouge">objects.h</code>中的宏<code class="highlighter-rouge">PyObject_VAR_HEAD</code>定义中，后面我们会涉及）</li>
</ul>

<p>所以，在我们的例子中，如果我们打印字节对象<code class="highlighter-rouge">s</code>, 将看到以下信息:</p>
<ul>
  <li><code class="highlighter-rouge">ob_sval</code>: 值为<code class="highlighter-rouge">Holberton</code> –&gt; 十六进制表示的ASCII码如下: <code class="highlighter-rouge">48</code> <code class="highlighter-rouge">6f</code> <code class="highlighter-rouge">6c</code> <code class="highlighter-rouge">62</code> <code class="highlighter-rouge">65</code> <code class="highlighter-rouge">72</code> <code class="highlighter-rouge">74</code> <code class="highlighter-rouge">6f</code> <code class="highlighter-rouge">6e</code> <code class="highlighter-rouge">00</code></li>
  <li><code class="highlighter-rouge">ob_size</code>: 值为<code class="highlighter-rouge">9</code></li>
</ul>

<p><strong>也即是说，字符串位于字节对象内部，所以和对象在同一内存区域。</strong></p>

<p>假如不知道CPython中内置函数<code class="highlighter-rouge">id()</code>返回的是对象的内存地址，我们如何查找字符串所在区域呢？这种情况下， 我们可以解析内存中的对象。</p>

<h2 id="五从内存中寻找目标字符串">五、从内存中寻找目标字符串</h2>

<p>如果想查看内存中的<code class="highlighter-rouge">PyBytesObject</code>变量， 我们需要写一个C函数，并且用Python调用这个C函数。Python可以通过多种方式调用C函数。我们仅使用最简单的动态库的方式。</p>

<h3 id="c函数原型">C函数原型</h3>
<p>我们要创建的C函数将被Python调用，它的入参是Python对象。该函数将剖析Python对象并找到字符串的地址，以及该对象的其他信息。</p>

<p>函数原型如下， 其中<code class="highlighter-rouge">p</code>是指向Python对象的指针:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void print_python_bytes(PyObject *p);
</code></pre></div></div>
<h3 id="objecth">object.h</h3>
<p>不知你是否注意到，<code class="highlighter-rouge">print_python_bytes</code>的入参类型不是<code class="highlighter-rouge">PyBytesObject</code>而是<code class="highlighter-rouge">PyObject</code>。为社么？让我们尝试从头文件<code class="highlighter-rouge">object.h</code>中寻找答案：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Object and type object interface */

/*
Objects are structures allocated on the heap.  Special rules apply to
the use of objects to ensure they are properly garbage-collected.
Objects are never allocated statically or on the stack; they must be
...
*/
</code></pre></div></div>

<ul>
  <li>“Python对象不能静态分配或者在栈上分配” –&gt; 这说明了为什么字符串不在栈上。</li>
  <li>“Python对象是在堆上分配的” –&gt; <strong><em>等等… 什么？？？我们在堆上寻找字符串但是并没找到啊…</em></strong>想不明白！我们将在另一篇文章中探讨这个问题。</li>
</ul>

<p>我们还能从头文件<code class="highlighter-rouge">object.h</code>中找到什么呢？</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
...
Objects do not float around in memory; once allocated an object keeps
the same size and address.  Objects that must hold variable-size data
...
*/
</code></pre></div></div>

<ul>
  <li>“对象在内存中是固定的：对象一经分配就保持固定大小，并且地址也不会再变化” –&gt; 这意味着，如果我们找到对应的字符串（字节对象中的字符串）并修改它，它将永远被改变。</li>
  <li>“一经分配” –&gt; 分配？但是不在堆中？想不明白！我们将在另一篇文章中探讨这个问题。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
...
Objects are always accessed through pointers of the type 'PyObject *'.
The type 'PyObject' is a structure that only contains the reference count
and the type pointer.  The actual memory allocated for an object
contains other data that can only be accessed after casting the pointer
to a pointer to a longer structure type.  This longer type must start
with the reference count and type fields; the macro PyObject_HEAD should be
used for this (to accommodate for future changes).  The implementation
of a particular object type can cast the object pointer to the proper
type and back.
...
*/
</code></pre></div></div>
<p><em>译者注：下面的意思大概可以类比成，<code class="highlighter-rouge">PyObject</code> 和 <code class="highlighter-rouge">PyBytesObject</code>是父类和子类的关系，通过父类只能访问父类的成员变量；如果想访问子类的成员变量，必须把类型转换成子类类型。</em></p>

<ul>
  <li>“对象总是由类型为<code class="highlighter-rouge">PyObject *</code>的指针访问” –&gt; 这就是函数<code class="highlighter-rouge">print_python_bytes</code>的入参类型是<code class="highlighter-rouge">PyObject</code>而不是<code class="highlighter-rouge">PyBytesObject</code>的原因。</li>
  <li>“每个对象所占用的包含其他信息的实际内存，只能通过转化后的具体的类型指针访问” –&gt; 因此，为了访问类型<code class="highlighter-rouge">PyBytesObject</code>的所有成员，我们必须把入参<code class="highlighter-rouge">PyObject *</code>转换成<code class="highlighter-rouge">PyBytesObject *</code>。这种转换是可行的，因为<code class="highlighter-rouge">PyBytesObject</code>的起始处是<code class="highlighter-rouge">PyVarObject</code>, 而<code class="highlighter-rouge">PyVarObject</code>的起始处又是个<code class="highlighter-rouge">PyObject</code>：</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* PyObject_VAR_HEAD defines the initial segment of all variable-size
 * container objects.  These end with a declaration of an array with 1
 * element, but enough space is malloc'ed so that the array actually
 * has room for ob_size elements.  Note that ob_size is an element count,
 * not necessarily a byte count.
 */
#define PyObject_VAR_HEAD      PyVarObject ob_base;
#define Py_INVALID_SIZE (Py_ssize_t)-1

/* Nothing is actually declared to be a PyObject, but every pointer to
 * a Python object can be cast to a PyObject*.  This is inheritance built
 * by hand.  Similarly every pointer to a variable-size Python object can,
 * in addition, be cast to PyVarObject*.
 */
typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt;
    struct _typeobject *ob_type;
} PyObject;

typedef struct {
    PyObject ob_base;
    Py_ssize_t ob_size; /* Number of items in variable part */
} PyVarObject;
</code></pre></div></div>
<p>这里我们看到了在<code class="highlighter-rouge">bytesobject.h</code>中提到的<code class="highlighter-rouge">ob_size </code>。</p>

<h3 id="c函数实现">C函数实现</h3>

<p>基于上面了解到的Python知识，我们可以写出打印Python对象的C函数（<code class="highlighter-rouge">bytes.c</code>）:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "Python.h"

/**
 * print_python_bytes - prints info about a Python 3 bytes object
 * @p: a pointer to a Python 3 bytes object
 * 
 * Return: Nothing
 */
void print_python_bytes(PyObject *p)
{
     /* The pointer with the correct type.*/
     PyBytesObject *s;
     unsigned int i;

     printf("[.] bytes object info\n");
     /* casting the PyObject pointer to a PyBytesObject pointer */
     s = (PyBytesObject *)p;
     /* never trust anyone, check that this is actually
        a PyBytesObject object. */
     if (s &amp;&amp; PyBytes_Check(s))
     {
          /* a pointer holds the memory address of the first byte
         of the data it points to */
          printf("  address of the object: %p\n", (void *)s);
          /* op_size is in the ob_base structure, of type PyVarObject. */
          printf("  size: %ld\n", s-&gt;ob_base.ob_size);
          /* ob_sval is the array of bytes, ending with the value 0:
         ob_sval[ob_size] == 0 */
          printf("  trying string: %s\n", s-&gt;ob_sval);
          printf("  address of the data: %p\n", (void *)(s-&gt;ob_sval));
          printf("  bytes:");
          /* printing each byte at a time, in case this is not
         a "string". bytes doesn't have to be strings.
         ob_sval contains space for 'ob_size+1' elements.
         ob_sval[ob_size] == 0. */
          for (i = 0; i &lt; s-&gt;ob_base.ob_size + 1; i++)
          {
               printf(" %02x", s-&gt;ob_sval[i] &amp; 0xff);
          }
          printf("\n");
     }
     /* if this is not a PyBytesObject print an error message */
     else
     {
          fprintf(stderr, "  [ERROR] Invalid Bytes Object\n");
     }
}
</code></pre></div></div>

<h3 id="python调用c函数">Python调用C函数</h3>

<h4 id="创建动态库">创建动态库</h4>
<p>如之前所述，我们将在Python脚本中用动态库的方式调用函数。我们可以用下面的命令编译C动态库：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -Wall -Wextra -pedantic -Werror -std=c99 -shared -Wl,-soname,libPython.so -o libPython.so -fPIC -I/usr/include/python3.4 bytes.c
</code></pre></div></div>
<p><em>提示：不要忘记包含Python3头文件目录:<code class="highlighter-rouge">-I/usr/include/python3.4</code></em></p>

<p>上面的命令将会创建动态库<code class="highlighter-rouge">libPython.so</code>。</p>

<h4 id="调用动态库">调用动态库</h4>

<p>为了调用动态库<code class="highlighter-rouge">libPython.so</code>中的函数，我们需要在Python脚本中增加下面的语句:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import ctypes

lib = ctypes.CDLL('./libPython.so')
lib.print_python_bytes.argtypes = [ctypes.py_object]
</code></pre></div></div>
<p>并用下面的方式调用函数:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lib.print_python_bytes(s)
</code></pre></div></div>
<h4 id="打印python对象的脚本">打印Python对象的脚本</h4>

<p>下面是用来打印Python字节对象的完整的Python脚本（<code class="highlighter-rouge">main_bytes.py</code>）:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span><span class="s">'''
Prints:
- the address of the bytes object
- a b"string" (bytes object)
- information about the bytes object
And then:
- reads a char from stdin
- prints the same (or not :)) information again
'''</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">ctypes</span>

<span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="p">.</span><span class="n">CDLL</span><span class="p">(</span><span class="s">'./libPython.so'</span><span class="p">)</span>
<span class="n">lib</span><span class="p">.</span><span class="n">print_python_bytes</span><span class="p">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="p">.</span><span class="n">py_object</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="s">b"Holberton"</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">lib</span><span class="p">.</span><span class="n">print_python_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">lib</span><span class="p">.</span><span class="n">print_python_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>
<p>让我们执行这个脚本:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ./main_bytes.py 
0x7f04d721b210
b'Holberton'
[.] bytes object info
  address of the object: 0x7f04d721b210
  size: 9
  trying string: Holberton
  address of the data: 0x7f04d721b230
  bytes: 48 6f 6c 62 65 72 74 6f 6e 00
</code></pre></div></div>

<p>不出所料：</p>
<ul>
  <li><code class="highlighter-rouge">id()</code>返回的是对象自身地址（<code class="highlighter-rouge">0x7f04d721b210</code>）</li>
  <li>字节对象<code class="highlighter-rouge">s</code>内部数据的大小(<code class="highlighter-rouge">ob_size</code>) 是9</li>
  <li>字节对象<code class="highlighter-rouge">s</code>的数据是字符串<code class="highlighter-rouge">Holberton</code>， 十六进制表示的ASCII码如下: <code class="highlighter-rouge">48</code> <code class="highlighter-rouge">6f</code> <code class="highlighter-rouge">6c</code> <code class="highlighter-rouge">62</code> <code class="highlighter-rouge">65</code> <code class="highlighter-rouge">72</code> <code class="highlighter-rouge">74</code> <code class="highlighter-rouge">6f</code> <code class="highlighter-rouge">6e</code> <code class="highlighter-rouge">00</code>，并且如<code class="highlighter-rouge">bytesobject.h</code>所言，是以<code class="highlighter-rouge">0x00</code>结尾的字符串。</li>
</ul>

<p>好了，我们已经找到字符串的准确地址<code class="highlighter-rouge">0x7f04d721b230</code>。</p>

<p><img src="http://data.coderhuo.tech/blog/virtual_memory/tumblr_nomr17FFSt1tym3lfo1_400.gif" alt="" /></p>

<h2 id="六替换python进程的字符串">六、替换Python进程的字符串</h2>

<p>现在我们已经了解了事情的来龙去脉，可以“暴力”搜索内存区域了。原来替换字符串的Python脚本只搜索堆段和栈段，现在我们让它搜索所有具有读写权限的内存区段。下面是具体的代码(<code class="highlighter-rouge">rw_all.py</code>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span><span class="s">'''
Locates and replaces (if we have permission) all occurrences of
an ASCII string in the entire virtual memory of a process.

Usage: ./rw_all.py PID search_string replace_by_string
Where:
- PID is the pid of the target process
- search_string is the ASCII string you are looking to overwrite
- replace_by_string is the ASCII string you want to replace
search_string with
'''</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">print_usage_and_exit</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Usage: {} pid search write'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># check usage
</span><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">print_usage_and_exit</span><span class="p">()</span>

<span class="c1"># get the pid from args
</span><span class="n">pid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">if</span> <span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">print_usage_and_exit</span><span class="p">()</span>
<span class="n">search_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="k">if</span> <span class="n">search_string</span>  <span class="o">==</span> <span class="s">""</span><span class="p">:</span>
    <span class="n">print_usage_and_exit</span><span class="p">()</span>
<span class="n">write_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="k">if</span> <span class="n">search_string</span>  <span class="o">==</span> <span class="s">""</span><span class="p">:</span>
    <span class="n">print_usage_and_exit</span><span class="p">()</span>

<span class="c1"># open the maps and mem files of the process
</span><span class="n">maps_filename</span> <span class="o">=</span> <span class="s">"/proc/{}/maps"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"[*] maps: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">maps_filename</span><span class="p">))</span>
<span class="n">mem_filename</span> <span class="o">=</span> <span class="s">"/proc/{}/mem"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"[*] mem: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mem_filename</span><span class="p">))</span>

<span class="c1"># try opening the file
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">maps_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'/proc/{}/maps'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pid</span><span class="p">),</span> <span class="s">'r'</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"[ERROR] Can not open file {}:"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">maps_filename</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"        I/O error({}): {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">strerror</span><span class="p">))</span>
    <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">maps_file</span><span class="p">:</span>
    <span class="c1"># print the name of the memory region
</span>    <span class="n">sline</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"[*] Searching in {}:"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="c1"># parse line
</span>    <span class="n">addr</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">inode</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">pathname</span> <span class="o">=</span> <span class="n">sline</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># check if there are read and write permissions
</span>    <span class="k">if</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'r'</span> <span class="ow">or</span> <span class="n">perm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'w'</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">[</span><span class="si">\</span><span class="se">x1B</span><span class="s">[31m!</span><span class="si">\</span><span class="se">x1B</span><span class="s">[m] {} does not have read/write permissions ({})"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">perm</span><span class="p">))</span>
        <span class="k">continue</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">pathname = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">addresses = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">permisions = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">perm</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">offset = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">inode = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>

    <span class="c1"># get start and end of the memoy region
</span>    <span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">"-"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># never trust anyone
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"[*] Wrong addr format"</span><span class="p">)</span>
        <span class="n">maps_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">addr_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">addr_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">Addr start [{:x}] | end [{:x}]"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">addr_start</span><span class="p">,</span> <span class="n">addr_end</span><span class="p">))</span>

    <span class="c1"># open and read the memory region
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="n">mem_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">mem_filename</span><span class="p">,</span> <span class="s">'rb+'</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"[ERROR] Can not open file {}:"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mem_filename</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"        I/O error({}): {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">strerror</span><span class="p">))</span>
        <span class="n">maps_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># read the memory region
</span>    <span class="n">mem_file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">addr_start</span><span class="p">)</span>
    <span class="n">region</span> <span class="o">=</span> <span class="n">mem_file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">addr_end</span> <span class="o">-</span> <span class="n">addr_start</span><span class="p">)</span>

    <span class="c1"># find string
</span>    <span class="n">nb_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">region</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">search_string</span><span class="p">,</span> <span class="s">"ASCII"</span><span class="p">))</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">[</span><span class="si">\</span><span class="se">x1B</span><span class="s">[32m:)</span><span class="si">\</span><span class="se">x1B</span><span class="s">[m] Found '{}' at {:x}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">search_string</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="n">nb_found</span> <span class="o">=</span> <span class="n">nb_found</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># write the new string
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">[:)] Writing '{}' at {:x}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">write_string</span><span class="p">,</span> <span class="n">addr_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>
            <span class="n">mem_file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">addr_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">mem_file</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">write_string</span><span class="p">,</span> <span class="s">"ASCII"</span><span class="p">))</span>
            <span class="n">mem_file</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span>

            <span class="c1"># update our buffer
</span>        <span class="n">region</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">write_string</span><span class="p">,</span> <span class="s">"ASCII"</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">region</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">search_string</span><span class="p">,</span> <span class="s">"ASCII"</span><span class="p">))</span>
    <span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nb_found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">\</span><span class="se">t</span><span class="s">[</span><span class="si">\</span><span class="se">x1B</span><span class="s">[31m:(</span><span class="si">\</span><span class="se">x1B</span><span class="s">[m] Can't find '{}'"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">search_string</span><span class="p">))</span>
    <span class="n">mem_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># close files
</span><span class="n">maps_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>让我们运行这个脚本:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ./main_bytes.py 
0x7f37f1e01210
b'Holberton'
[.] bytes object info
  address of the object: 0x7f37f1e01210
  size: 9
  trying string: Holberton
  address of the data: 0x7f37f1e01230
  bytes: 48 6f 6c 62 65 72 74 6f 6e 00
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ps aux | grep main_bytes.py | grep -v grep
julien     4713  0.0  0.8  37720  8208 pts/0    S+   18:48   0:00 python3 ./main_bytes.py
julien@holberton:~/holberton/w/hackthevm1$ sudo ./rw_all.py 4713 Holberton "~ Betty ~"
[*] maps: /proc/4713/maps
[*] mem: /proc/4713/mem
[*] Searching in /usr/bin/python3.4:
    [!] /usr/bin/python3.4 does not have read/write permissions (r-xp)
...
[*] Searching in [heap]:
    pathname = [heap]
    addresses = 00e26000-00f11000
    permisions = rw-p
    offset = 00000000
    inode = 0
    Addr start [e26000] | end [f11000]
    [:)] Found 'Holberton' at 8e422
    [:)] Writing '~ Betty ~' at eb4422
...
[*] Searching in :
    pathname = 
    addresses = 7f37f1df1000-7f37f1fa7000
    permisions = rw-p
    offset = 00000000
    inode = 0
    Addr start [7f37f1df1000] | end [7f37f1fa7000]
    [:)] Found 'Holberton' at 10230
    [:)] Writing '~ Betty ~' at 7f37f1e01230
...
[*] Searching in [stack]:
    pathname = [stack]
    addresses = 7ffdc3d0c000-7ffdc3d2d000
    permisions = rw-p
    offset = 00000000
    inode = 0
    Addr start [7ffdc3d0c000] | end [7ffdc3d2d000]
    [:(] Can't find 'Holberton'
...
julien@holberton:~/holberton/w/hackthevm1$ 
</code></pre></div></div>

<p>现在我们按下回车键继续运行脚本<code class="highlighter-rouge">main_bytes.py</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julien@holberton:~/holberton/w/hackthevm1$ ./main_bytes.py 
0x7f37f1e01210
b'Holberton'
[.] bytes object info
  address of the object: 0x7f37f1e01210
  size: 9
  trying string: Holberton
  address of the data: 0x7f37f1e01230
  bytes: 48 6f 6c 62 65 72 74 6f 6e 00

0x7f37f1e01210
b'~ Betty ~'
[.] bytes object info
  address of the object: 0x7f37f1e01210
  size: 9
  trying string: ~ Betty ~
  address of the data: 0x7f37f1e01230
  bytes: 7e 20 42 65 74 74 79 20 7e 00
julien@holberton:~/holberton/w/hackthevm1$ 
</code></pre></div></div>

<p>很好， 成功把字符串<code class="highlighter-rouge">Holberton</code>替换成<code class="highlighter-rouge">~ Betty ~</code>。</p>

<p><img src="http://data.coderhuo.tech/blog/virtual_memory/giphy-3.gif" alt="" /></p>

<h2 id="七下节预告">七、下节预告</h2>
<p>本文我们成功修改了正在运行的Python3脚本中的字符串，但是仍有几个问题有待解答：</p>
<ul>
  <li>堆中的字符串<code class="highlighter-rouge">Holberton</code>是干什么的？</li>
  <li>Python3如何在堆以外分配内存？</li>
  <li>如果Python3没有使用堆，头文件<code class="highlighter-rouge">object.h</code>中所说的“对象是堆上的结构”又该如何解释？</li>
</ul>

<p>下一篇文章我们将一一解答上面的问题。</p>

<h2 id="八继续阅读">八、继续阅读</h2>

<ul>
  <li>第一篇:<a href="http://blog.coderhuo.tech/2017/10/12/Virtual_Memory_C_strings_proc/">虚拟内存探究 – 第一篇:C strings &amp; /proc</a></li>
  <li>第二篇:<a href="http://blog.coderhuo.tech/2017/10/15/Virtual_Memory_python_bytes/">虚拟内存探究 – 第二篇:Python 字节</a></li>
  <li>第三篇:<a href="http://blog.coderhuo.tech/2017/10/16/Virtual_Memory_drawing_VM_diagram/">虚拟内存探究 – 第三篇:一步一步画虚拟内存图</a></li>
  <li>第四篇:<a href="http://blog.coderhuo.tech/2017/10/18/Virtual_Memory_malloc_and_heap/">虚拟内存探究 – 第四篇:malloc, heap &amp; the program break</a></li>
  <li>第五篇:<a href="http://blog.coderhuo.tech/2019/08/31/Virtual_Memory_malloc_and_heap_stack_and_register/">虚拟内存探究 – 第五篇:The Stack, registers and assembly code</a></li>
</ul>

<h2 id="九原文链接">九、原文链接</h2>
<p><a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/">Hack The Virtual Memory: Python bytes</a></p>
:ET